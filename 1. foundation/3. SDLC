
# SDLC â€“ Software Development Life Cycle

This chapter is critical to make you industry-ready â€” because 90% of a testerâ€™s work depends on SDLC. 
If you understand how the product is built, youâ€™ll know when and what to test.

### ğŸ“Œ Chapter Structure:
Weâ€™ll go step by step:

1. What is SDLC?
2. Why Manual Testers Must Understand SDLC
3. SDLC Phases (Detailed Breakdown):
   Requirement Gathering & Analysis
   Feasibility Study
   Design
   Development
   Testing
   Deployment
   Maintenance

4. SDLC Models (Waterfall, Agile, V-Model, Iterative, Spiral)
5. Testerâ€™s Role in Each Phase (Real-life Activities)
6. Documents Generated in Each Phase

\\\

### What is SDLC?
SDLC (Software Development Life Cycle) is the framework that defines the process used by software companies to 
design, develop, test, deploy, and maintain software systems.
Think of it as a step-by-step plan for building software efficiently and with fewer bugs.

ğŸ” Definition:
"SDLC is a systematic process for building software that ensures the quality and correctness of the software being built."

## Why SDLC is Critical for Manual Testers
Most beginners think testing is only involved in the â€œtesting phaseâ€ â€” thatâ€™s completely wrong.

Hereâ€™s why you need to understand the full SDLC:

SDLC Phase                                     	Why It Matters for Testers
Requirements	                         You need to analyze testable requirements, and identify missing pieces
Design	                               Understanding design helps you prepare test scenarios early
Development	                           You can start writing test cases even before coding finishes
Testing	                               Of course â€” this is your battlefield
Deployment                           	 You need to do post-deployment sanity/smoke
Maintenance	                           You test bug fixes, patches, and version updates

If you donâ€™t understand SDLC:

1. Youâ€™ll write late or poor test cases
2. Youâ€™ll miss critical bugs
3. Youâ€™ll be confused when asked whatâ€™s your role in the early stages

âœ… HR/Managers prefer testers who talk about their involvement from the beginning of SDLC.

\\\

# Lets talk about the development process in detail to understand it fully.

ğŸ”¸ 1. Requirement Gathering & Analysis
What happens:
Business Analysts talk to the client
Collect Business Requirements Document (BRD)
Conduct stakeholder meetings

Deliverables:
BRD (Business Requirement Document)
SRS (Software Requirement Specification)

Testerâ€™s Role:
Attend requirement review meetings
Ask questions: Whatâ€™s testable? Whatâ€™s unclear?
Start preparing Requirement Traceability Matrix (RTM)

Real-world Example:
If the client says:
â€œI want a feature to reset password via email.â€

As a tester, you should ask:
What if the email is invalid?
Should it expire?
Should it block after 3 failed attempts?
Can it work on mobile and web?

Thatâ€™s how critical thinking begins.


ğŸ”¸ 2. Feasibility Study
What happens:
Technical team checks: Is this possible?

Budget, time, manpower estimated

Testerâ€™s Role:
Generally low involvement, but senior testers may assist in estimating testing efforts

ğŸ”¸ 3. Design

What happens:
Architects & designers create system architecture
High-level design (HLD) and low-level design (LLD) are created

Deliverables:
HLD: Overall structure (modules, flow)
LLD: Detailed blueprint of components

Testerâ€™s Role:
Analyze data flow
Identify integration points and test entry/exit points
Prepare test scenarios based on HLD

ğŸ”¸ 4. Development
What happens:
Developers write code based on the design

Testerâ€™s Role:
Start preparing test cases
Set up test environment
Perform static testing (review code, documents if permitted)

ğŸ”¸ 5. Testing
What happens:
Code is deployed to QA environment
Testing begins: Smoke, Functional, Integration, Regression, etc.

Testerâ€™s Role:
Execute test cases
Log defects
Retest and close bugs
Prepare daily QA reports

ğŸ”¸ 6. Deployment
What happens:
Code is moved to production environment

Testerâ€™s Role:
Do production sanity testing
Validate deployment success
Raise rollback alerts if needed

ğŸ”¸ 7. Maintenance
What happens:
Monitor system performance
Fix post-production bugs
Apply patches

Testerâ€™s Role:
Retest bug fixes
Perform regression for new builds
Ensure system stability

\\\

### Now lets understand different types of SDLC models .

ğŸ”¶ What is an SDLC Model?
An SDLC Model is simply a method or approach followed by a team to complete each phase of the software development life cycle (requirement â†’ maintenance).

Each company uses a model based on:

Project size & complexity
Budget
Timeline flexibility
Need for customer feedback

As a tester, understanding these models helps you:

Know when youâ€™ll be involved
Prepare test cases in time
Plan for early or late-stage testing
Communicate effectively with devs and stakeholders


ğŸ§­ List of Most Common SDLC Models:

1. Waterfall Model
2. V-Model
3. Iterative Model
4. Spiral Model
5. Agile Model (most important)
6. [Brief] Big Bang & Prototype Model (just awareness)

\\\

ğŸ”· 1. Waterfall Model
Requirement â†’ Design â†’ Development â†’ Testing â†’ Deployment â†’ Maintenance

ğŸ”¹ Key Points:

Linear and rigid
Best for small, well-defined projects
Testing comes late (after development)

ğŸ”¹ Testerâ€™s Role:
Gets involved after development
High chance of missing early bugs
No flexibility to modify test cases mid-way

ğŸ”¹ Pros:
âœ” Simple, easy to manage
âœ” Good documentation

ğŸ”¹ Cons:
âœ˜ No feedback during development
âœ˜ Late testing = more costly bug fixes
âœ˜ Not suitable for evolving projects

ğŸ”¹ Real Use Case:
Govt. projects, fixed-scope corporate software

\\

ğŸ”· 2. V-Model (Verification & Validation)
ğŸ”¹ Flow:
Every dev phase has a corresponding test phase
Moves down for development, and up for testing (like a "V")

Requirement    â†’   Design    â†’ Development
    â†“                          â†“
Acceptance Test â† System Test â† Integration Test â† Unit Test

Acceptance Test â† System Test â† Integration Test â† Unit Test

ğŸ”¹ Testerâ€™s Role:
Involved early
Test plans are created parallel to dev phases
You prepare acceptance, system, integration tests as dev continues

ğŸ”¹ Pros:
âœ” Early testing â†’ early bug detection
âœ” Quality-focused

ğŸ”¹ Cons:
âœ˜ Rigid like Waterfall
âœ˜ Expensive to change specs once started

ğŸ”¹ Use Case:
Projects requiring early risk reduction (like banking systems)

\\

ğŸ”· 3. Iterative Model
â†’ Requirement â†’ Design â†’ Development â†’ Testing â†’ Feedback â†’ Next Version

Product is built in versions (iterations)
Feedback is used to improve next cycle
Each version includes its own testing

ğŸ”¹ Testerâ€™s Role:
Write and execute test cases for each version
Perform regression testing on previous features
Help in test planning for next iteration

ğŸ”¹ Pros:
âœ” Feedback-driven
âœ” Fast improvement

ğŸ”¹ Cons:
âœ˜ Design issues may appear late
âœ˜ Integration complexity grows

ğŸ”¹ Use Case:
Web applications with evolving features

\\

ğŸ”· 4. Spiral Model
Planning â†’ Risk Analysis â†’ Engineering (dev & test) â†’ Evaluation â†’ Repeat

Combines iterative + risk analysis
Suitable for large and high-risk projects

ğŸ”¹ Testerâ€™s Role:
Perform risk-based testing
Help create test plans for each cycle
Give feedback on risk areas found during testing

ğŸ”¹ Pros:
âœ” Great for risk control
âœ” Flexible with new requirements

ğŸ”¹ Cons:
âœ˜ Complex
âœ˜ Costly
âœ˜ Not suitable for small projects

ğŸ”¹ Use Case:
Healthcare systems, aerospace, fintech products

\\

ğŸ”· 5. Agile Model â€“ Most Used Today ğŸ”¥

ğŸ”¹ Flow:
Product is built in small cycles called sprints (1â€“4 weeks)
Each sprint includes:
1. Planning
2. Dev
3. Testing
4. Review
Teams work collaboratively: Dev + QA + BA + Product Owner
Based on the Agile Manifesto (values customer collaboration, working software, flexibility)

Sprint 1 â†’ Sprint 2 â†’ Sprint 3 â†’ â€¦

ğŸ”¹ Testerâ€™s Role:
Deep involvement from Day 1
Write user story-based test cases
Attend daily standups, sprint reviews
Do functional, regression, exploratory testing every sprint

ğŸ”¹ Pros:
âœ” Quick delivery
âœ” Fast feedback
âœ” Changes are easy to accommodate
âœ” Continuous testing and improvement

ğŸ”¹ Cons:
âœ˜ High pressure
âœ˜ Poor documentation sometimes
âœ˜ Needs discipline to work well

ğŸ”¹ Use Case:
Startups, SaaS companies, ecommerce apps (e.g., Swiggy, Amazon)

\\

âš¡ Quick Comparison Table: 
Model	                                             Tester Involvement	                  Flexibility	                               Use Case
Waterfall                                              	Late	                             Low	                            Small, fixed-scope projects
V-Model	                                                Early	                             Low	                            Secure, quality-focused apps
Iterative                                             	Medium	                           Medium	                          Mid-size evolving apps
Spiral	                                                Medium + Risk-based	               High	                            High-stakes large systems
Agile	                                                  Continuous	                       Very High	                      Most modern IT companies

\\\

